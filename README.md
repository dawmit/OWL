# Owl

A Java implementation of the Owl PAKE protocol.

Owl is an Augmented Password Key Exchange Protocol, developed by
Feng Hao, Samiran Bag, Liqun Chan, Paul van Oorschot, in this paper: [Owl: An Augmented 
Password-Authenticated Key Exchange Scheme](https://eprint.iacr.org/2023/768.pdf).

Functionality includes the registration of a new user on the a
server, and the authentication of an existing user through the
username and password login system.

This implementation was developed using elliptic curve 
cryptography and does not support prime order group cryptography
unless extended.

## Installation

To install the package, run:

```git clone https://github.com/dawmit/OWL.git```

This will clone the repository locally.

## Build and Run

To build the package, run:

```./gradlew build```

To run the tests manually, run:

```./gradlew test```

To run without the tests, run:

```./gradlew run -x test```

## Usage

To use this protocol as part of your application go to the `Owl_
Example` class to see an example usage of this protocol.

There are two seperate modes of functionality: user registration
and user authentication:

### Registration
To register a user on the server you must first construct an `Owl_ClientRegistration` and `Owl_ServerRegistration` package.

```Owl_ClientRegistration client = new Owl_ClientRegistration("username", "password".toCharArray(), curve, digest, random);
Owl_ServerRegistration server = new Owl_ServerRegistration("serverId", curve, digest2, random2);
````

Remember that the elliptic curve you choose has to be the same for both server and client otherwise the calculations will fail. You should choose a pre-existing from `Owl_Curves`, to avoid any vulnerabilities caused by insecure curve parameters.

Now to register a user, the client creates an `Owl_InitialRegistration` payload that must be sent to the server over a secure communications channel, otherwise passive attackers will be able to calculate the secret password.

```Owl_InitialRegistration registrationPayload = client.initiateUserRegistration();
Owl_FinishRegistration toBeStoredOnServer = server.registerUseronServer(registrationPayload);
```

Then server uses the payload generated by the client, to generate its own secret payload `Owl_FinishRegistration` that is to be stored externally, and securely, for use in the authentication phase.  

### Authentication
For authentication, similar to registration, we must create a client and server, again remember to use the same curve for each client and server as well as the same curve used to register the users currently attempting to log in.

```Owl_Client client = new Owl_Client("username", "password".toCharArray(), curve, digest, random);
Owl_Server serve = new Owl_Client("serverId", curve, digest, random);
```

Passwords must mach for authentication to proceed.

Now call the following methods in this order:

``` Owl_AuthenticationInitiate clientLoginStart = client.authenticationInitiate();
 Owl_AuthenticationServerResponse serverLoginResponse = server.authenticationServerResponse(clientLoginStart, serverUserRegistration);
 Owl_AuthenticationFinish clientLoginEnd = client.authenticationFinish(serverLoginResponse);
 server.authenticationServerEnd(clientLoginEnd);
 ```

 This completes the handshake protocol, now to generate the keying material:

 ``` BigInteger clientKeyingMaterial = client.calculateKeyingMaterial();
  BigInteger serverKeyingMaterial = server.calculateKeyingMaterial();
  ```
  To derive a full session key, a secure Key Derivation Function must be used, this is to be handled externally by the user.

### Explicit Key Confirmation
  Here, is an optional third round of the protocol that explicitly checks whether or not the keys generated by the handshake are equal. Without performing this step, the user has no way of knowing whether or not both the client and server generated the same keys (as they should).

  ```Owl_KeyConfirmation clientKCPayload = client.initiateKeyConfirmation(clientKeyingMaterial);
  Owl_KeyConfirmation serverKCPayload = server.initiateKeyConfirmation(serverKeyingMaterial);
  client.validateKeyConfirmation(serverKCPayload, clientKeyingMaterial);
  server.validateKeyConfirmation(clientKCPayload, serverKeyingMaterial);
  ```

  If there are no errors, then the keys are a match! Using you're own KDF you can derive a session key from the `clientKeyingMaterial` and `serverKeyingMaterial`.

  The password update functionality is to be handled externally at the application layer.
