package org.example;

import java.math.BigInteger;
import java.security.SecureRandom;

import org.bouncycastle.crypto.CryptoException;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Exceptions;

/**
 * A serve in a Password Authenticated Key Exchange by Juggling (Owl) exchange.
 * <p>
 * The Owl exchange is defined by Feng Hao and Peter Ryan in the paper
 * <a href="https://eprint.iacr.org/2023/768.pdf">
 * "Owl: An Augmented Password-Authenticated Key Exchange Scheme"</a>
 * <p>
 * The Owl protocol is asymmetric.
 * There is one client and one server communicating between each other.
 * An instance of {@link Owl_Server} represents one server, and
 * an instance of {@link Owl_Client} represents one client.
 * These together make up the main machine through which the protocol is facilitated.
 * <p>
 * To execute an exchange, construct a {@link Owl_Server} on the server end,
 * and construct a {@link Owl_Client} on the client end.
 * Each Owl exchange will need a new and distinct {@link Owl_Server} and {@link Owl_Client}.
 * You cannot use the same {@link Owl_Server} for multiple {@link Owl_Client}.
 * There are three distinct actions that can be taken: user registration - where the client registers
 * as a new user on the server; login - where an existing user (client) attempts to login and the Owl protocl authenticates this
 * exchange; and password change - where the user (client) can change their password.
 * <p>
 * For user registration the following methods must be called once and in this order by the specified entity (server/client):
 * THIS FOLLOWING USER REGISTRATION PROTOCOL MUST BE EXECUTED USING A SECURE COMMUNICATION CHANNEL.
 * The contents sent between client and server here cannot be leaked as the entire login process will be compromised.
 * <ol>
 * <li>{@link Owl_Client#initiateUserRegistration()} - this function is to be sent by the client to the server and it initiates user login regsitration. Contents must be sent over secure channel.</li>
 * <li>{@link Owl_Server#registerUseronServer(Owl_InitialRegistration)} - the output of this function is to be saved securely by the server, and is not sent back to the client.</li>
 * </ol>
 * <p>
 * To execute the login authenitcation protocol, as in the login registration, both
 * {@link Owl_Server} and {@link Owl_Client} must be constructed. 
 * Unlike in the login registration the follow communications do not have to be sent via secure channels.
 * Call the follwowing methods in this order, the client initiates every exchange. 
 * <li> {@link Owl_Client#authenticationInitiate()} - send payload to the server </li>
 * <li> {@link Owl_Server#authenticationServerResponse(Owl_AuthenticationInitiate, Owl_FinishRegistration)} - use the payload recieved from the client as well the user credentials stored in the server from user registration, and send the payload generated to the client.</li>
 * <li> {@link Owl_Client#authenticationFinish(OWL_AuthenticationServerResponse)} - use the payload from the server and send next payload generated by this function back to the server. </li>
 * <li> {@link Owl_Server#authenticationServerEnd(Owl_AuthenticationFinish)} - use the payload from the client.</li>
 * <li> {@link #calculateKeyingMaterial()} - both the server and the client execute this to generate the final key. </li>
 * <li>{@link #initiateKeyConfirmation(BigInteger)} - and send the payload to the other serve. This is called by both client and server.</li>
 * <li>{@link validateKeyConfirmation(Owl_KeyConfirmation, BigInteger)} - use the payload received from the other serve. This is called by both client and server.</li>
 * <p>
 * Each side should derive a session key from the keying material returned by {@link #calculateKeyingMaterial()}.
 * The caller is responsible for deriving the session key using a secure key derivation function (KDF).
 * <p>
 * Round 3 is an optional key confirmation process.
 * If you do not execute round 3, then there is no assurance that both client and server are using the same key.
 * (i.e. if the client and server used different passwords (remember the server does not have access to the password, only the secret from which it was derived), then their session keys will differ.)
 * <p>
 * If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides.
 * <p>
 * The key confirmation process is implemented as specified in
 * <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">NIST SP 800-56A Revision 3</a>,
 * Section 5.9.1 Unilateral Key Confirmation for Key Agreement Schemes.
 * <p>
 * This class is stateful and NOT threadsafe.
 * Each instance should only be used for ONE complete Owl exchange
 * (i.e. a new {@link Owl_Server} and {@link Owl_Client} should be constructed for each new Owl exchange).
 * <p>
 */
public class Owl_Server
{

    /*
     * Possible internal states.  Used for state checking.
     */
    public static final int STATE_INITIALISED = 0;
    public static final int STATE_LOGIN_INITIALISED = 10;
    public static final int STATE_LOGIN_FINISHED = 20;
    public static final int STATE_KEY_CALCULATED = 30;
    public static final int STATE_KC_INITIALISED = 40;
    public static final int STATE_KC_VALIDATED = 50;

    /**
     * Unique identifier of this serve.
     * The two serves in the exchange must NOT share the same id.
     */
    private final String serverId;

    /**
     * Unique identifier for the client in the exchange.
     */
    private String clientId;

    /**
     * Digest to use during calculations.
     */
    private final Digest digest;

    /**
     * Source of secure random data.
     */
    private final SecureRandom random;

    /**
     * The serverId of the server in this exchange.
     */

    private ECCurve.AbstractFp ecCurve;
    private BigInteger q;
    private BigInteger h;
    private BigInteger n;
    private ECPoint g;

    /**
     * Server's x4.
     */
    private BigInteger x4;
    /**
     * Client's gx1.
     */
    private ECPoint gx1;
    /**
     * Client's gx2.
     */
    private ECPoint gx2;
    /**
     * Server's gx3.
     */
    private ECPoint gx3;
    /**
     * Server's gx4.
     */
    private ECPoint gx4;
    /**
     * Client's user specified secret t = H(username||password) mod n
     */
    private BigInteger t;
    /**
     * Shared secret used for authentication pi = H(t) mod n
     */
    private BigInteger pi;
    /**
     * Client's T, Password verifier stored on server
     */
    private ECPoint gt;
    /**
     * Server's beta value used in login authentication
     */
    private ECPoint beta;
    /**
     * ECSchnorrZKP knowledge proof for x1, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX1;
    /**
     * ECSchnorrZKP knowledge proof for x2, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX2;
    /**
     * ECSchnorrZKP knowledge proof for x3, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX3;
    /**
     * ECSchnorrZKP knowledge proof for x4, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX4;
    /**
     * ECSchnorrZKP knowledge proof for beta, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForBeta;
    /**
     *  The raw key K used to calculate a session key.
     */
    private ECPoint rawKey;
    /**
     * The current state.
     * See the <tt>STATE_*</tt> constants for possible values.
     */
    private int state;

    /**
     * Convenience constructor for a new {@link Owl_Server} that uses
     * the {@link Owl_Curves#NIST_P256} elliptic curve,
     * a SHA-256 digest, and a default {@link SecureRandom} implementation.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALISED}.
     *
     * @param serverId unique identifier of this server.
     *                      The server and client in the exchange must NOT share the same id.
     * @throws NullPointerException     if any argument is null
     */
    public Owl_Server(
        String serverId)
    {
        this(
            serverId,
            Owl_Curves.NIST_P256);
    }

    /**
     * Convenience constructor for a new {@link Owl_Server} that uses
     * a SHA-256 digest and a default {@link SecureRandom} implementation.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALISED}.
     *
     * @param serverId unique identifier of this server.
     *                      The server and client in the exchange must NOT share the same id.
     * @param curve         elliptic curve
     *                      See {@link Owl_Curves} for standard curves.
     * @throws NullPointerException     if any argument is null
     */
    public Owl_Server(
        String serverId,
        Owl_Curve curve)
    {
        this(
            serverId,
            curve,
            SHA256Digest.newInstance(),
            CryptoServicesRegistrar.getSecureRandom());
    }

    /**
     * Construct a new {@link Owl_Server}.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALISED}.
     *
     * @param serverId unique identifier of this server.
     *                      The client and server in the exchange must NOT share the same id.
     *                      See {@link Owl_Curves} for standard curves
     * @param digest        digest to use during zero knowledge proofs and key confirmation (SHA-256 or stronger preferred)
     * @param random        source of secure random data for x3 and x4, and for the zero knowledge proofs
     * @throws NullPointerException     if any argument is null
     */
    public Owl_Server(
        String serverId,
        Owl_Curve curve,
        Digest digest,
        SecureRandom random)
    {
        Owl_Util.validateNotNull(serverId, "serverId");
        Owl_Util.validateNotNull(curve, "curve params");
        Owl_Util.validateNotNull(digest, "digest");
        Owl_Util.validateNotNull(random, "random");

        this.serverId = serverId;

        this.ecCurve = curve.getCurve();
        this.g = curve.getG();
        this.h = curve.getH();
        this.n = curve.getN();
        this.q = curve.getQ();

        this.digest = digest;
        this.random = random;

        this.state = STATE_INITIALISED;
    }

    /**
     * Gets the current state of this serve.
     * See the <tt>STATE_*</tt> constants for possible values.
     */
    public int getState()
    {
        return this.state;
    }

    /**
     * Validates the payload sent by {@link #authenticationInitiate()} by {@link Owl_Client}, and then creates a new {@link Owl_AuthenticationServerResponse} payload and sends it to the client.
     * <p>
     * Must be called prior to {@link #authenticationServerEnd(Owl_AuthenticationFinish)}.
     * <p>
     * After execution, the {@link #getState() state} will be {@link #STATE_LOGIN_INITIALISED}.
     *
     * @param userLoginCredentials comes from the server where it stored the user login credentials as part of the user login registration.
     * @throws CryptoException       if validation fails.
     * @throws IllegalStateException if called multiple times.
     */
    public Owl_AuthenticationServerResponse authenticationServerResponse(
        Owl_AuthenticationInitiate authenticationInitiate, 
        Owl_FinishRegistration userLoginCredentials)
        throws CryptoException
    {
        if (this.state >= STATE_LOGIN_INITIALISED)
        {
            throw new IllegalStateException("Server already created payload for response to client login initiation, by " + serverId);
        }
        this.clientId = authenticationInitiate.getClientId();
        this.gx1 = authenticationInitiate.getGx1();
        this.gx2 = authenticationInitiate.getGx2();

        this.knowledgeProofForX1 = authenticationInitiate.getKnowledgeProofForX1();
        this.knowledgeProofForX2 = authenticationInitiate.getKnowledgeProofForX2();

        Owl_Util.validateParticipantIdsDiffer(serverId, authenticationInitiate.getClientId());
        Owl_Util.validateZeroknowledgeProof(g, gx1, knowledgeProofForX1, q, n, ecCurve, h, authenticationInitiate.getClientId(), digest);
        Owl_Util.validateZeroknowledgeProof(g, gx2, knowledgeProofForX2, q, n, ecCurve, h, authenticationInitiate.getClientId(), digest);

        this.x4 = Owl_Util.generateX1(n, random);

        this.gx4 = Owl_Util.calculateGx(g, x4);

        this.knowledgeProofForX4 = Owl_Util.calculateZeroknowledgeProof(g, n, x4, gx4, digest, serverId, random);

        this.gx3 = userLoginCredentials.getGx3();
        this.pi  = userLoginCredentials.getPi();
        //Perhaps to an explicit check for pi!= 0 ??
        this.knowledgeProofForX3 = userLoginCredentials.getKnowledgeProofForX3();
        this.gt = userLoginCredentials.getGt();

        Owl_Util.validateParticipantIdsEqual(this.clientId, userLoginCredentials.getClientId());

        ECPoint betaG = Owl_Util.calculateGA(gx1, gx2, gx3);
        BigInteger x4pi = Owl_Util.calculateX2s(n, x4, pi);
        this.beta = Owl_Util.calculateA(betaG, x4pi);
        this.knowledgeProofForBeta = Owl_Util.calculateZeroknowledgeProof(betaG, n, x4pi, beta, digest, serverId, random);

        this.state = STATE_LOGIN_INITIALISED;

        return new Owl_AuthenticationServerResponse(serverId, gx3, gx4, knowledgeProofForX3, knowledgeProofForX4, beta, knowledgeProofForBeta);
    }

    /**
     * Validates the payload received from the client during the second pass.
     * <p>
     * Note that this DOES NOT detect a non-common password.
     * The only indication of a non-common password is through derivation
     * of different keys (which can be detected explicitly by executing round 3 and round 4)
     * <p>
     * Must be called prior to {@link #calculateKeyingMaterial()}.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_LOGIN_FINISHED}.
     *
     * @throws CryptoException       if validation fails.
     * @throws IllegalStateException if called prior to {@link #authenticationServerResponse(Owl_AuthenticationInitiate, Owl_FinishRegistration)}, or multiple times
     */
    public void authenticationServerEnd(Owl_AuthenticationFinish authenticationFinish)
        throws CryptoException
    {
        if (this.state >= STATE_LOGIN_FINISHED)
        {
            throw new IllegalStateException("Authentication finish payload already created and validated by " + serverId);
        }
        if (this.state < STATE_LOGIN_INITIALISED)
        {
            throw new IllegalStateException("Authentication server response required before authentication finish by " + this.serverId);
        }

        ECPoint alpha =  authenticationFinish.getAlpha();
        ECPoint alphaG = Owl_Util.calculateGA(gx1, gx3, gx4);
        ECSchnorrZKP knowledgeProofForAlpha = authenticationFinish.getKnowledgeProofForAlpha();
        
        Owl_Util.validateZeroknowledgeProof(alphaG, alpha, knowledgeProofForAlpha, q, n, ecCurve, h, clientId, digest);

        BigInteger x4pi = Owl_Util.calculateX2s(n, x4, pi);
        this.rawKey = Owl_Util.calculateKeyingMaterial(gx2, x4, x4pi, alpha);

        BigInteger hTranscript = Owl_Util.calculateTranscript(rawKey, clientId, gx1, gx2, knowledgeProofForX1, knowledgeProofForX2, serverId, gx3, gx4, 
            knowledgeProofForX3, knowledgeProofForX4, beta, knowledgeProofForBeta, alpha, knowledgeProofForAlpha, digest);

        Owl_Util.validateR(authenticationFinish.getR(), gx1, hTranscript, gt, g, n);
        Owl_Util.validateParticipantIdsDiffer(serverId, authenticationFinish.getClientId());
        Owl_Util.validateParticipantIdsEqual(this.clientId, authenticationFinish.getClientId());

        this.state = STATE_LOGIN_FINISHED;
    }

    /**
     * Calculates and returns the key material.
     * A session key must be derived from this key material using a secure key derivation function (KDF).
     * The KDF used to derive the key is handled externally (i.e. not by {@link Owl_Server}).
     * <p>
     * The keying material will be identical for client and server if and only if
     * the login password is the same as password stored by the server.  i.e. If the client and  
     * server do not share the same password, then each  will derive a different key.
     * Therefore, if you immediately start using a key derived from
     * the keying material, then you must handle detection of incorrect keys.
     * If you want to handle this detection explicitly, you can optionally perform
     * rounds 3 and 4.  See {@link Owl_Server} for details on how to execute
     * rounds 3 and 4.
     * <p>
     * The keying material will be in the range <tt>[0, n-1]</tt>.
     * <p>
     * {@link #authenticationServerEnd(Owl_AuthenticationFinish)} must be called prior to this method.
     * <p>
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_KEY_CALCULATED}.
     *
     * @throws IllegalStateException if called prior to {@link #authenticationServerEnd(Owl_AuthenticationFinish)},
     *                               or if called multiple times.
     */
    public BigInteger calculateKeyingMaterial()
    {
        if (this.state >= STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Key already calculated for " + serverId);
        }
        if (this.state < STATE_LOGIN_FINISHED)
        {
            throw new IllegalStateException("Round2 payload must be validated prior to creating key for " + serverId);
        }

        BigInteger keyingMaterial = Owl_Util.deriveKCKey(rawKey);

        /*
         * Clear the ephemeral private key fields as well.
         * Note that we're relying on the garbage collector to do its job to clean these up.
         * The old objects will hang around in memory until the garbage collector destroys them.
         *
         * If the ephemeral private key x4 are leaked,
         * the attacker might be able to brute-force the password.
         */
        this.x4 = null;
        this.beta = null;
        this.rawKey = null;

        /*
         * Do not clear gx* yet, since those are needed by round 3.
         */
        this.state = STATE_KEY_CALCULATED;

        return keyingMaterial;
    }

    /**
     * Creates and returns the payload to send to the client as part of Key Confirmation.
     * <p>
     * See {@link Owl_Server} for more details on Key Confirmation.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_KC_INITIALISED}.
     *
     * @param keyingMaterial The keying material as returned from {@link #calculateKeyingMaterial()}.
     * @throws IllegalStateException if called prior to {@link #calculateKeyingMaterial()}, or multiple times
     */
    public Owl_KeyConfirmation initiateKeyConfirmation(BigInteger keyingMaterial)
    {
        if (this.state >= STATE_KC_INITIALISED)
        {
            throw new IllegalStateException("Round3 payload already created for " + this.serverId);
        }
        if (this.state < STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Keying material must be calculated prior to creating Round3 payload for " + this.serverId);
        }

        BigInteger macTag = Owl_Util.calculateMacTag(
            this.serverId,
            this.clientId,
            this.gx3,
            this.gx4,
            this.gx1,
            this.gx2,
            keyingMaterial,
            this.digest);

        this.state = STATE_KC_INITIALISED;

        return new Owl_KeyConfirmation(serverId, macTag);
    }

    /**
     * Validates the payload received from the client as part of Key Confirmation.
     * <p>
     * See {@link Owl_Server} for more details on Key Confirmation.
     * <p>
     * After execution, the {@link #getState() state} will be {@link #STATE_KC_VALIDATED}.
     *
     * @param keyConfirmationPayload The key confirmation payload received from the client..
     * @param keyingMaterial        The keying material as returned from {@link #calculateKeyingMaterial()}.
     * @throws CryptoException       if validation fails.
     * @throws IllegalStateException if called prior to {@link #calculateKeyingMaterial()}, or multiple times
     */
    public void validateKeyConfirmation(Owl_KeyConfirmation keyConfirmationPayload, BigInteger keyingMaterial)
        throws CryptoException
    {
        if (this.state >= STATE_KC_VALIDATED)
        {
            throw new IllegalStateException("Validation already attempted for third pass payload for" + serverId);
        }
        if (this.state < STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Keying material must be calculated validated prior to validating third pass payload for " + this.serverId);
        }
        Owl_Util.validateParticipantIdsDiffer(serverId, keyConfirmationPayload.getId());
        Owl_Util.validateParticipantIdsEqual(this.clientId, keyConfirmationPayload.getId());

        Owl_Util.validateMacTag(
            this.serverId,
            this.clientId,
            this.gx3,
            this.gx4,
            this.gx1,
            this.gx2,
            keyingMaterial,
            this.digest,
            keyConfirmationPayload.getMacTag());

        /*
         * Clear the rest of the fields.
         */
        this.gx1 = null;
        this.gx2 = null;
        this.gx3 = null;
        this.gx4 = null;

        this.state = STATE_KC_VALIDATED;
    }
}