package org.bouncycastle.crypto.agreement.Owl;

import java.math.BigInteger;
import java.security.SecureRandom;

import org.bouncycastle.crypto.CryptoException;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Exceptions;

/**
 * A client in a Password Authenticated Key Exchange by Juggling (Owl) exchange.
 * <p>
 * The Owl exchange is defined by Feng Hao and Peter Ryan in the paper
 * <a href="https://eprint.iacr.org/2023/768.pdf">
 * "Owl: An Augmented Password-Authenticated Key Exchange Scheme"</a>
 * <p>
 * The Owl protocol is asymmetric.
 * There is one client and one server communicating between each other.
 * An instance of {@link Owl_Server} represents one server, and
 * an instance of {@link Owl_Client} represents one client.
 * These together make up the main machine through which the protocol is facilitated.
 * <p>
 * To execute an exchange, construct a {@link Owl_Server} on the server end,
 * and construct a {@link Owl_Client} on the client end.
 * There are three distinct actions that can be taken: user registration - where the client registers
 * as a new user on the server; login - where an existing user (client) attempts to login and the Owl protocl authenticates this
 * exchange; and password change - where the user (client) can change their password.
 * <p>
 * For user registration the following methods must be called once and in this order by the specified entity (server/client):
 * THIS FOLLOWING USER REGISTRATION PROTOCOL MUST BE EXECUTED USING A SECURE COMMUNICATION CHANNEL.
 * The contents sent between client and server here cannot be leaked as the entire login process will be compromised.
 * <ol>
 * <li>{@link Owl_Client#initiateUserRegistration()} - this function is to be sent by the client to the server and it initiates user login regsitration. Contents must be sent over secure channel.</li>
 * <li>{@link Owl_Server#registerUseronServer(Owl_InitialRegistration)} - the output of this function is to be saved securely by the server, and is not sent back to the client.</li>
 * </ol>
 * <p>
 * To execute the login authenitcation protocol, as in the login registration, both
 * {@link Owl_Server} and {@link Owl_Client} must be constructed. 
 * Unlike in the login registration the follow communications do not have to be sent via secure channels.
 * Call the follwowing methods in this order, the client initiates every exchange. 
 * <li> {@link Owl_Client#authenticationInitiate()} - send payload to the server </li>
 * <li> {@link Owl_Server#authenticationServerResponse(Owl_AuthenticationInitiate, Owl_FinishRegistration)} - use the payload recieved from the client as well the user credentials stored in the server from user registration, and send the payload generated to the client.</li>
 * <li> {@link Owl_Client#authenticationFinish(Owl_AuthenticationServerResponse)} - use the payload from the server and send next payload generated by this function back to the server. </li>
 * <li> {@link Owl_Server#authenticationServerEnd(Owl_AuthenticationFinish)} - use the payload from the client.</li>
 * <li> {@link #calculateKeyingMaterial()} - both the server and the client execute this to generate the final key. </li>
 * <li>{@link #initiateKeyConfirmation(BigInteger)} - and send the payload to the other client. This is called by both client and server.</li>
 * <li>{@link validateKeyConfirmation(Owl_KeyConfirmation, BigInteger)} - use the payload received from the other client. This is called by both client and server.</li>
 * <p>
 * Each side should derive a session key from the keying material returned by {@link #calculateKeyingMaterial()}.
 * The caller is responsible for deriving the session key using a secure key derivation function (KDF).
 * <p>
 * Round 3 is an optional key confirmation process.
 * If you do not execute round 3, then there is no assurance that both clients are using the same key.
 * (i.e. if the clients used different passwords, then their session keys will differ.)
 * <p>
 * If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides.
 * <p>
 * The key confirmation process is implemented as specified in
 * <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">NIST SP 800-56A Revision 3</a>,
 * Section 5.9.1 Unilateral Key Confirmation for Key Agreement Schemes.
 * <p>
 * This class is stateful and NOT threadsafe.
 * Each instance should only be used for ONE complete Owl exchange
 * (i.e. a new {@link Owl_Server} and {@link Owl_Client} should be constructed for each new Owl exchange).
 * <p>
 */
public class Owl_Client
{

    /*
     * Possible internal states.  Used for state checking.
     */
    public static final int STATE_INITIALISED = 0;
    public static final int STATE_LOGIN_INITIALISED = 10;
    public static final int STATE_LOGIN_FINISHED = 20;
    public static final int STATE_KEY_CALCULATED = 30;
    public static final int STATE_KC_INITIALISED = 40;
    public static final int STATE_KC_VALIDATED = 50;

    /*
     * Possible state for user registration.
     */
    public static final boolean REGISTRATION_NOT_CALLED = false;
    public static final boolean REGISTRATION_CALLED = true;

    /**
     * Unique identifier of this client.
     * The client and server in the exchange must NOT share the same id.
     * clientId is the same as the username in this PAKE
     */
    private final String clientId;

    /**
     * Shared secret.  This only contains the secret between construction
     * and the call to {@link #calculateKeyingMaterial()}.
     * <p>
     * i.e. When {@link #calculateKeyingMaterial()} is called, this buffer overwritten with 0's,
     * and the field is set to null.
     * </p>
     */
    private char[] password;

    /**
     * Digest to use during calculations.
     */
    private final Digest digest;

    /**
     * Source of secure random data.
     */
    private final SecureRandom random;

    /**
     * The serverId of the server in this exchange.
     */
    private String serverId; 

    private ECCurve.AbstractFp ecCurve;
    private BigInteger q;
    private BigInteger h;
    private BigInteger n;
    private ECPoint g;

    /**
     * Client's x1
     */
    private BigInteger x1;
    /**
     * Client's x2.
     */
    private BigInteger x2;
    /**
     Client's gx1.
     */
    private ECPoint gx1;
    /**
     * Client's gx2.
     */
    private ECPoint gx2;
    /**
     * Server's gx3.
     */
    private ECPoint gx3;
    /**
     * Server's gx4.
     */
    private ECPoint gx4;
    /**
     * Client's user specified secret t = H(username||password) mod n
     */
    private BigInteger t;
    /**
     * Shared secret used for authentication pi = H(t) mod n
     */
    private BigInteger pi;
    /**
     * Client's T, Password verifier stored on server
     */
    private ECPoint gt;
    /**
     * The current state.
     * See the <tt>STATE_*</tt> constants for possible values.
     */
    private int state;
    /**
     * Checks if user registration is called more than once.
     */
    private boolean registrationState;
    /**
     *  The raw key K used to calculate a session key.
     */
    private ECPoint rawKey;
    /**
     * Client's alpha
     */
    private ECPoint alpha;

    /**
     * Convenience constructor for a new {@link Owl_Client} that uses
     * the {@link Owl_Curves#NIST_P256} elliptic curve,
     * a SHA-256 digest, and a default {@link SecureRandom} implementation.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALIZED}.
     *
     * @param clientId unique identifier of this client.
     *                      The server and client in the exchange must NOT share the same id.
     * @param password      shared secret.
     *                      A defensive copy of this array is made (and cleared once {@link #calculateKeyingMaterial()} is called).
     *                      Caller should clear the input password as soon as possible.
     * @throws NullPointerException     if any argument is null
     * @throws IllegalArgumentException if password is empty
     */
    public Owl_Client(
        String clientId,
        char[] password)
    {
        this(
            clientId,
            password,
            Owl_Curves.NIST_P256);
    }

    /**
     * Convenience constructor for a new {@link Owl_Client} that uses
     * a SHA-256 digest and a default {@link SecureRandom} implementation.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALIZED}.
     *
     * @param clientId unique identifier of this client..
     *                      The server and client in the exchange must NOT share the same id.     
     * @param password      shared secret.
     *                      A defensive copy of this array is made (and cleared once {@link #calculateKeyingMaterial()} is called).
     *                      Caller should clear the input password as soon as possible.
     * @param curve         elliptic curve
     *                      See {@link Owl_Curves} for standard curves.
     * @throws NullPointerException     if any argument is null
     * @throws IllegalArgumentException if password is empty
     */
    public Owl_Client(
        String clientId,
        char[] password,
        Owl_Curve curve)
    {
        this(
            clientId,
            password,
            curve,
            SHA256Digest.newInstance(),
            CryptoServicesRegistrar.getSecureRandom());
    }

    /**
     * Construct a new {@link Owl_Client}.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALIZED}.
     *
     * @param clientId unique identifier of this client.
     *                      The server and client in the exchange must NOT share the same id.
     * @param password      shared secret.
     *                      A defensive copy of this array is made (and cleared once {@link #calculateKeyingMaterial()} is called).
     *                      Caller should clear the input password as soon as possible.
     * @param curve         elliptic curve.
     *                      See {@link Owl_Curves} for standard curves
     * @param digest        digest to use during zero knowledge proofs and key confirmation (SHA-256 or stronger preferred)
     * @param random        source of secure random data for x1 and x2, and for the zero knowledge proofs
     * @throws NullPointerException     if any argument is null
     * @throws IllegalArgumentException if password is empty
     */
    public Owl_Client(
        String clientId,
        char[] password,
        Owl_Curve curve,
        Digest digest,
        SecureRandom random)
    {
        Owl_Util.validateNotNull(clientId, "clientId");
        Owl_Util.validateNotNull(password, "password");
        Owl_Util.validateNotNull(curve, "curve params");
        Owl_Util.validateNotNull(digest, "digest");
        Owl_Util.validateNotNull(random, "random");
        if (password.length == 0)
        {
            throw new IllegalArgumentException("Password must not be empty.");
        }

        this.clientId = clientId;

        /*
         * Create a defensive copy so as to fully encapsulate the password.
         *
         * This array will contain the password for the lifetime of this
         * client BEFORE {@link #calculateKeyingMaterial()} is called.
         *
         * i.e. When {@link #calculateKeyingMaterial()} is called, the array will be cleared
         * in order to remove the password from memory.
         *
         * The caller is responsible for clearing the original password array
         * given as input to this constructor.
         */
        this.password = Arrays.copyOf(password, password.length);

        this.ecCurve = curve.getCurve();
        this.g = curve.getG();
        this.h = curve.getH();
        this.n = curve.getN();
        this.q = curve.getQ();

        this.digest = digest;
        this.random = random;

        this.state = STATE_INITIALIZED;
        this.registrationState = REGISTRATION_NOT_CALLED;
    }

    /**
     * Gets the current state of this client.
     * See the <tt>STATE_*</tt> constants for possible values.
     */
    public int getState()
    {
        return this.state;
    }

    /**
     * Check's the status of the user registration
     * I.E. whether or not this server has registered a user already.
     * See the <tt>REGSITRATION_*</tt> constants for possible values.
     */
    public int getRegistrationState()
    {
        return this.registrationState;
    }

    /**
     * Initiates user registration with the server. Creates the registration payload {@link Owl_InitialRegistration} and sends it to the server.
     * MUST be sent over a secure channel.
     * <p>
     * Must be called prior to {@link #registerUseronServer(Owl_InitialRegistration)}
     * @throws IllegalStateException if this function is called more than once
     */
    public Owl_InitialRegistration initiateUserRegistration()
    {
        if(this.registrationState)
        {
            throw new IllegalStateException("User login registration already begun by "+ clientId);
        }
        BigInteger t = calculateT();

        BigInteger pi = Owl_Util.caculatePi(t);

        ECPoint gt = Owl_Util.calculateGx(g, t);

        this.registrationState = REGISTRATION_CALLED;

        return new Owl_InitialRegistration(clientId, pi, gt);
    }

    /**
     * Creates and returns the payload to send to the server as part of the second pass of the protocol.
     * <p>
     * Must be called prior to {@link #authenticationFinish()}
     * After execution, the {@link #getState() state} will be  {@link #STATE_LOGIN_INITIALISED}.
     * 
     * @throws IllegalStateException if called multiple times.
     */
    public Owl_AuthenticationInitiate authenticationInitiate()
    {
        if (this.state >= STATE_LOGIN_INITIALISED)
        {
            throw new IllegalStateException("Login already initiated by " + clientId);
        }
        this.t = calculateT();

        this.pi = Owl_Util.caculatePi(t);

        this.x1 = Owl_Util.generateX1(n, random);
        this.x2 = Owl_Util.generateX1(n, random);

        this.gx1 = Owl_Util.calculateGx(g, x1);
        this.gx2 = Owl_Util.calculateGx(g, x2);

        ECSchnorrZKP knowledgeProofForX1 = Owl_Util.calculateZeroknowledgeProof(g, n, x1, gx1, digest, clientId, random);
        ECSchnorrZKP knowledgeProofForX2 = Owl_Util.calculateZeroknowledgeProof(g, n, x2, gx2, digest, clientId, random);

        this.state = STATE_LOGIN_INITIALISED;

        return new Owl_AuthenticationInitiate(clientId, gx1, gx2, knowledgeProofForX1, knowledgeProofForX2);
    }

    /**
     * Finalises the login authentication protocol by creating and sending the payload to the server.
     * Validates the payload sent by the server after login initilisation.
     * <p>
     * Must be called prior to {@link #calculateKeyingMaterial()}.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_LOGIN_FINISHED}.
     *
     * @throws CryptoException       if validation fails.
     * @throws IllegalStateException if called prior to {@link #authenticationInitiate()} or called multiple times.
     */
    public Owl_AuthenticationFinish authenticationFinish(Owl_AuthenticationServerResponse authenticationServerResponse) 
        throws CryptoException
    {
        if (this.state >= STATE_LOGIN_FINISHED)
        {
            throw new IllegalStateException("Validation already attempted for round1 payload for" + clientId);
        }
        this.serverId = authenticationServerResponse.getServerId();
        this.gx3 = authenticationServerResponse.getGx3();
        this.gx4 = authenticationServerResponse.getGx4();
        ECPoint beta = authenticationServerResponse.getBeta();
        ECSchnorrZKP knowledgeProofForX3 = authenticationServerResponse.getknowledgeProofForX3();
        ECSchnorrZKP knowledgeProofForX4 = authenticationServerResponse.getknowledgeProofForX4();
        ECSchnorrZKP knowledgeProofForBeta = authenticationServerResponse.getknowledgeProofForBeta();

        ECPoint betaG = calculateGA(gx1, gx2, gx3);

        Owl_Util.validateclientIdsDiffer(clientId, authenticationServerResponse.getServerId());
        Owl_Util.validateZeroknowledgeProof(g, gx3, knowledgeProofForX3, q, n, ecCurve, h, authenticationServerResponse.serverId(), digest);
        Owl_Util.validateZeroknowledgeProof(g, gx4, knowledgeProofForX4, q, n, ecCurve, h, authenticationServerResponse.serverId(), digest);
        Owl_Util.validateZeroknowledgeProof(betaG, beta, knowledgeProofForBeta, q, n, ecCurve, h, authenticationServerResponse.serverId(), digest);

        ECPoint alphaG = Owl_Util.calculateGA(gx1, gx3, gx4);
        BigInteger x2pi = Owl_Util.calculateX2s(n, x2, pi); 
        this.alpha = Owl_Util.calculateA(alphaG, x2pi);

        ECSchnorrZKP knowledgeProofForAlpha  = Owl_Util.calculateZeroknowledgeProof(alphaG, n, x2pi, alpha, digest, clientId, random);

        this.rawKey = Owl_Util.calculateKeyingMaterial(gx4, x2, x2pi, beta);

        BigInteger hTranscript = Owl_Util.calculateTranscript(rawKey, clientId, gx1, gx2, knowledgeProofX1, knowledgeProofX2, serverId, gx3, gx4, 
            knowledgeProofX3, knowledgeProofX4, beta, knowledgeProofBeta, alpha, knowledgeProofForAlpha, digest);

        BigInteger r = Owl_Util.calculateR(x1, t, hTranscript, n);

        this.state = STATE_LOGIN_FINISHED;

        return new Owl_AuthenticationFinish(clientId, alpha, knowledgeProofForAlpha, r);
    }


    /**
     * Calculates and returns the key material.
     * A session key must be derived from this key material using a secure key derivation function (KDF).
     * The KDF used to derive the key is handled externally (i.e. not by {@link Owl_Client}).
     * <p>
     * The keying material will be identical for client and server if and only if
     * the login password is the same as password stored by the server.  i.e. If the client and  
     * server do not share the same password, then each  will derive a different key.
     * Therefore, if you immediately start using a key derived from
     * the keying material, then you must handle detection of incorrect keys.
     * If you want to handle this detection explicitly, you can optionally perform
     * rounds 3 and 4.  See {@link Owl_Client} for details on how to execute
     * rounds 3 and 4.
     * <p>
     * The keying material will be in the range <tt>[0, n-1]</tt>.
     * <p>
     * {@link #authenticationFinish(Owl_AuthenticationServerResponse)} must be called prior to this method.
     * <p>
     * As a side effect, the internal {@link #password} array is cleared, since it is no longer needed.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_KEY_CALCULATED}.
     *
     * @throws IllegalStateException if called prior to {@link #authenticationFinish(Owl_AuthenticationServerResponse)},
     *                               or if called multiple times.
     */
    public BigInteger calculateKeyingMaterial()
    {
        if (this.state >= STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Key already calculated for " + clientId);
        }
        if (this.state < STATE_LOGIN_FINISHED)
        {
            throw new IllegalStateException("Login authentication must be finished prior to creating key for " + clientId);
        }

        /*
         * Clear the password array from memory, since we don't need it anymore.
         *
         * Also set the field to null as a flag to indicate that the key has already been calculated.
         */
        Arrays.fill(password, (char)0);
        this.password = null;

        BigInteger keyingMaterial = Owl_Util.calculateHash(rawKey);

        /*
         * Clear the ephemeral private key fields as well.
         * Note that we're relying on the garbage collector to do its job to clean these up.
         * The old objects will hang around in memory until the garbage collector destroys them.
         *
         * If the ephemeral private keys x1 and x2 are leaked,
         * the attacker might be able to brute-force the password.
         */
        this.x1 = null;
        this.x2 = null;
        this.alpha = null;
        this.rawKey = null;

        /*
         * Do not clear gx* yet, since those are needed by round 3.
         */
        this.state = STATE_KEY_CALCULATED;

        return keyingMaterial;
    }

    /**
     * Creates and returns the payload to send to the client as part of Key Confirmation.
     * <p>
     * See {@link Owl_Client} for more details on Key Confirmation.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_KC_INITIALISED}.
     *
     * @param keyingMaterial The keying material as returned from {@link #calculateKeyingMaterial()}.
     * @throws IllegalStateException if called prior to {@link #calculateKeyingMaterial()}, or multiple times
     */
    public Owl_KeyConfirmation initiateKeyConfirmation(BigInteger keyingMaterial)
    {
        if (this.state >= STATE_KC_INITIALISED)
        {
            throw new IllegalStateException("Round3 payload already created for " + this.clientId);
        }
        if (this.state < STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Keying material must be calculated prior to creating Round3 payload for " + this.clientId);
        }

        BigInteger macTag = Owl_Util.calculateMacTag(
            this.clientId,
            this.serverId,
            this.gx1,
            this.gx2,
            this.gx3,
            this.gx4,
            keyingMaterial,
            this.digest);

        this.state = STATE_KC_INITIALISED;

        return new Owl_KeyConfirmation(clientId, macTag);
    }

    /**
     * Creates and returns the payload to send to the client as part of Key Confirmation.
     * <p>
     * See {@link Owl_Client} for more details on Key Confirmation.
     * <p>
     * After execution, the {@link #getState() state} will be {@link #STATE_KC_VALIDATED}.
     *
     * @param keyConfirmationPayload The key confirmation payload received from the other client.
     * @param keyingMaterial        The keying material as returned from {@link #calculateKeyingMaterial()}.
     * @throws CryptoException       if validation fails.
     * @throws IllegalStateException if called prior to {@link #calculateKeyingMaterial()}, or multiple times
     */
    public void validateKeyConfirmation(Owl_KeyConfirmation keyConfirmationPayload, BigInteger keyingMaterial)
        throws CryptoException
    {
        if (this.state >= STATE_KC_VALIDATED)
        {
            throw new IllegalStateException("Validation already attempted for round3 payload for" + clientId);
        }
        if (this.state < STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Keying material must be calculated validated prior to validating Round3 payload for " + this.clientId);
        }
        Owl_Util.validateIdsDiffer(clientId, keyConfirmationPayload.getId());
        Owl_Util.validateIdsEqual(this.serverId, keyConfirmationPayload.getId());

        Owl_Util.validateMacTag(
            this.clientId,
            this.serverId,
            this.gx1,
            this.gx2,
            this.gx3,
            this.gx4,
            keyingMaterial,
            this.digest,
            keyConfirmationPayload.getMacTag());


        /*
         * Clear the rest of the fields.
         */
        this.gx1 = null;
        this.gx2 = null;
        this.gx3 = null;
        this.gx4 = null;

        this.state = STATE_KC_VALIDATED;
    }

    private BigInteger calculateT()
    {
        try 
        {
            return Owl_Util.calculateT(n, clientId + new String(password), digest);
        } 
        catch (CryptoException e)
        {
            throw Exceptions.illegalStateException(e.getMessage(), e);
        }
    }
}