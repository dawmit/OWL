package org.example;

import java.math.BigInteger;
import java.security.SecureRandom;

import org.bouncycastle.crypto.CryptoException;
import org.bouncycastle.crypto.CryptoServicesRegistrar;
import org.bouncycastle.crypto.Digest;
import org.bouncycastle.crypto.digests.SHA256Digest;
import org.bouncycastle.math.ec.ECCurve;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.util.Arrays;
import org.bouncycastle.util.Exceptions;

/**
 * A client in a Password Authenticated Key Exchange by Juggling (Owl) exchange.
 * <p>
 * The Owl exchange is defined by Feng Hao and Peter Ryan in the paper
 * <a href="https://eprint.iacr.org/2023/768.pdf">
 * "Owl: An Augmented Password-Authenticated Key Exchange Scheme"</a>
 * <p>
 * The Owl protocol is asymmetric.
 * There is one client and one server communicating between each other.
 * An instance of {@link Owl_Server} represents one server, and
 * an instance of {@link Owl_Client} represents one client.
 * These together make up the main machine through which the protocol is facilitated.
 * <p>
 * To execute an exchange, construct a {@link Owl_Server} on the server end,
 * and construct a {@link Owl_Client} on the client end.
 * There are three distinct actions that can be taken: user registration - where the client registers
 * as a new user on the server; login - where an existing user (client) attempts to login and the Owl protocl authenticates this
 * exchange; and password change - where the user (client) can change their password.
 * <p>
 * For user registration go to {@link Owl_ClientRegistration} and {@link Owl_ServerRegistration}.
 * To execute the login authenitcation protocol, as in the login registration, both
 * {@link Owl_Server} and {@link Owl_Client} must be constructed. 
 * Unlike in the login registration the follow communications do not have to be sent via secure channels.
 * Call the follwowing methods in this order, the client initiates every exchange. 
 * <li> {@link Owl_Client#authenticationInitiate()} - send payload to the server </li>
 * <li> {@link Owl_Server#authenticationServerResponse(Owl_AuthenticationInitiate, Owl_FinishRegistration)} - use the payload recieved from the client as well the user credentials stored in the server from user registration, and send the payload generated to the client.</li>
 * <li> {@link Owl_Client#authenticationFinish(OWL_AuthenticationServerResponse)} - use the payload from the server and send next payload generated by this function back to the server. </li>
 * <li> {@link Owl_Server#authenticationServerEnd(Owl_AuthenticationFinish)} - use the payload from the client.</li>
 * <li> {@link #calculateKeyingMaterial()} - both the server and the client execute this to generate the final key. </li>
 * <li>{@link #initiateKeyConfirmation(BigInteger)} - send the payload to the other participant in this exchange (client/server). This is called by both client and server.</li>
 * <li>{@link validateKeyConfirmation(Owl_KeyConfirmation, BigInteger)} - use the payload received from the other participant (client/server). This is called by both client and server.</li>
 * <p>
 * Each side should derive a session key from the keying material returned by {@link #calculateKeyingMaterial()}.
 * The caller is responsible for deriving the session key using a secure key derivation function (KDF).
 * <p>
 * Round 3 is an optional key confirmation process.
 * If you do not execute round 3, then there is no assurance that both client and server are using the same key.
 * (i.e. if the client and server used different passwords (remember the server does not have access to the password, only the secret from which it was derived), then their session keys will differ.)
 * If the passwords used for registration were not the same as the password used to login, then the validation of r fails in, {@link Owl_Server#authenticationServerEnd(Owl_AuthenticationFinish)}.
 * <p>
 * If the round 3 validation succeeds, then the keys are guaranteed to be the same on both sides.
 * <p>
 * The key confirmation process is implemented as specified in
 * <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">NIST SP 800-56A Revision 3</a>,
 * Section 5.9.1 Unilateral Key Confirmation for Key Agreement Schemes.
 * <p>
 * This class is stateful and NOT threadsafe.
 * Each instance should only be used for ONE complete Owl exchange
 * (i.e. a new {@link Owl_Server} and {@link Owl_Client} should be constructed for each new Owl exchange).
 * <p>
 */
public class Owl_Client
{

    /*
     * Possible internal states.  Used for state checking.
     */
    public static final int STATE_INITIALISED = 0;
    public static final int STATE_LOGIN_INITIALISED = 10;
    public static final int STATE_LOGIN_FINISHED = 20;
    public static final int STATE_KEY_CALCULATED = 30;
    public static final int STATE_KC_INITIALISED = 40;
    public static final int STATE_KC_VALIDATED = 50;

    /**
     * Unique identifier of this client.
     * The client and server in the exchange must NOT share the same id.
     * clientId is the same as the username in this PAKE
     */
    private final String clientId;

    /**
     * Shared secret.  This only contains the secret between construction
     * and the call to {@link #calculateKeyingMaterial()}.
     * <p>
     * i.e. When {@link #calculateKeyingMaterial()} is called, this buffer overwritten with 0's,
     * and the field is set to null.
     * </p>
     */
    private char[] password;

    /**
     * Digest to use during calculations.
     */
    private final Digest digest;

    /**
     * Source of secure random data.
     */
    private final SecureRandom random;

    /**
     * The serverId of the server in this exchange.
     */
    private String serverId; 

    private ECCurve.AbstractFp ecCurve;
    private BigInteger q;
    private BigInteger h;
    private BigInteger n;
    private ECPoint g;
    /**
     * Client's x1
     */
    private BigInteger x1;
    /**
     * Client's x2.
     */
    private BigInteger x2;
    /**
     Client's gx1.
     */
    private ECPoint gx1;
    /**
     * Client's gx2.
     */
    private ECPoint gx2;
    /**
     * Server's gx3.
     */
    private ECPoint gx3;
    /**
     * Server's gx4.
     */
    private ECPoint gx4;
    /**
     * Client's user specified secret t = H(username||password) mod n
     */
    private BigInteger t;
    /**
     * Shared secret used for authentication pi = H(t) mod n
     */
    private BigInteger pi;
    /**
     * The current state.
     * See the <tt>STATE_*</tt> constants for possible values.
     */
    private int state;
    /**
     *  The raw key K used to calculate a session key.
     */
    private ECPoint rawKey;
    /**
     * Client's alpha
     */
    private ECPoint alpha;
    /**
     * ECSchnorrZKP knowledge proof for x1, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX1;
    /**
     * ECSchnorrZKP knowledge proof for x2, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX2;
    /**
     * ECSchnorrZKP knowledge proof for x3, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX3;
    /**
     * ECSchnorrZKP knowledge proof for x4, using {@link ECSchnorrZKP}
     */
    private ECSchnorrZKP knowledgeProofForX4;

    /**
     * Convenience constructor for a new {@link Owl_Client} that uses
     * the {@link Owl_Curves#NIST_P256} elliptic curve,
     * a SHA-256 digest, and a default {@link SecureRandom} implementation.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALISED}.
     *
     * @param clientId      unique identifier of this client.
     *                      The server and client in the exchange must NOT share the same id.
     * @param password      shared secret.
     *                      A defensive copy of this array is made (and cleared once {@link #calculateKeyingMaterial()} is called).
     *                      Caller should clear the input password as soon as possible.
     * @throws NullPointerException     if any argument is null
     * @throws IllegalArgumentException if password is empty
     */
    public Owl_Client(
        String clientId,
        char[] password)
    {
        this(
            clientId,
            password,
            Owl_Curves.NIST_P256);
    }

    /**
     * Convenience constructor for a new {@link Owl_Client} that uses
     * a SHA-256 digest and a default {@link SecureRandom} implementation.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALISED}.
     *
     * @param clientId      unique identifier of this client.
     *                      The server and client in the exchange must NOT share the same id.     
     * @param password      shared secret.
     *                      A defensive copy of this array is made (and cleared once {@link #calculateKeyingMaterial()} is called).
     *                      Caller should clear the input password as soon as possible.
     * @param curve         elliptic curve
     *                      See {@link Owl_Curves} for standard curves.
     * @throws NullPointerException     if any argument is null
     * @throws IllegalArgumentException if password is empty
     */
    public Owl_Client(
        String clientId,
        char[] password,
        Owl_Curve curve)
    {
        this(
            clientId,
            password,
            curve,
            SHA256Digest.newInstance(),
            CryptoServicesRegistrar.getSecureRandom());
    }

    /**
     * Construct a new {@link Owl_Client}.
     * <p>
     * After construction, the {@link #getState() state} will be  {@link #STATE_INITIALISED}.
     *
     * @param clientId      unique identifier of this client.
     *                      The server and client in the exchange must NOT share the same id.
     * @param password      shared secret.
     *                      A defensive copy of this array is made (and cleared once {@link #calculateKeyingMaterial()} is called).
     *                      Caller should clear the input password as soon as possible.
     * @param curve         elliptic curve.
     *                      See {@link Owl_Curves} for standard curves
     * @param digest        digest to use during zero knowledge proofs and key confirmation (SHA-256 or stronger preferred)
     * @param random        source of secure random data for x1 and x2, and for the zero knowledge proofs
     * @throws NullPointerException     if any argument is null
     * @throws IllegalArgumentException if password is empty
     */
    public Owl_Client(
        String clientId,
        char[] password,
        Owl_Curve curve,
        Digest digest,
        SecureRandom random)
    {
        Owl_Util.validateNotNull(clientId, "clientId");
        Owl_Util.validateNotNull(password, "password");
        Owl_Util.validateNotNull(curve, "curve params");
        Owl_Util.validateNotNull(digest, "digest");
        Owl_Util.validateNotNull(random, "random");
        if (password.length == 0)
        {
            throw new IllegalArgumentException("Password must not be empty.");
        }

        this.clientId = clientId;

        /*
         * Create a defensive copy so as to fully encapsulate the password.
         *
         * This array will contain the password for the lifetime of this
         * client BEFORE {@link #calculateKeyingMaterial()} is called.
         *
         * i.e. When {@link #calculateKeyingMaterial()} is called, the array will be cleared
         * in order to remove the password from memory.
         *
         * The caller is responsible for clearing the original password array
         * given as input to this constructor.
         */
        this.password = Arrays.copyOf(password, password.length);

        this.ecCurve = curve.getCurve();
        this.g = curve.getG();
        this.h = curve.getH();
        this.n = curve.getN();
        this.q = curve.getQ();

        this.digest = digest;
        this.random = random;

        this.state = STATE_INITIALISED;
    }

    /**
     * Gets the current state of this client.
     * See the <tt>STATE_*</tt> constants for possible values.
     */
    public int getState()
    {
        return this.state;
    }
    /**
     * Creates and returns the payload to send to the server as part of the first pass of the protocol.
     * <p>
     * Must be called prior to {@link #authenticationFinish()}
     * After execution, the {@link #getState() state} will be  {@link #STATE_LOGIN_INITIALISED}.
     * 
     * @throws IllegalStateException if called multiple times.
     */
    public Owl_AuthenticationInitiate authenticationInitiate()
    {
        if (this.state >= STATE_LOGIN_INITIALISED)
        {
            throw new IllegalStateException("Login already initiated by " + clientId);
        }
        this.t = calculateT();

        this.pi = calculatePi();

        this.x1 = Owl_Util.generateX1(n, random);
        this.x2 = Owl_Util.generateX1(n, random);

        this.gx1 = Owl_Util.calculateGx(g, x1);
        this.gx2 = Owl_Util.calculateGx(g, x2);

        this.knowledgeProofForX1 = Owl_Util.calculateZeroknowledgeProof(g, n, x1, gx1, digest, clientId, random);
        this.knowledgeProofForX2 = Owl_Util.calculateZeroknowledgeProof(g, n, x2, gx2, digest, clientId, random);

        this.state = STATE_LOGIN_INITIALISED;

        return new Owl_AuthenticationInitiate(clientId, gx1, gx2, knowledgeProofForX1, knowledgeProofForX2);
    }

    /**
     * Finalises the login authentication protocol by creating and sending the final payload to the server.
     * Validates the payload sent by the {@link Owl_Server#authenticationServerResponse(Owl_AuthenticationInitiate, Owl_FinishRegistration)} after login initilisation.
     * <p>
     * Must be called prior to {@link #calculateKeyingMaterial()}.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_LOGIN_FINISHED}.
     * 
     * @param authenticationServerResponse  The payload sent by {@link Owl_Server#authenticationServerResponse(Owl_AuthenticationInitiate, Owl_FinishRegistration)} and to be validated.
     *
     * @throws CryptoException       if validation fails.
     * @throws IllegalStateException if called prior to {@link #authenticationInitiate()} or called multiple times.
     */
    public Owl_AuthenticationFinish authenticationFinish(Owl_AuthenticationServerResponse authenticationServerResponse) 
        throws CryptoException
    {
        if (this.state >= STATE_LOGIN_FINISHED)
        {
            throw new IllegalStateException("Login authentication already finished by: " + clientId);
        }
        if (this.state < STATE_LOGIN_INITIALISED)
        {
            throw new IllegalStateException("Must initialise login authentication before calling authentication finish for: " + clientId);
        }
        this.serverId = authenticationServerResponse.getServerId();
        this.gx3 = authenticationServerResponse.getGx3();
        this.gx4 = authenticationServerResponse.getGx4();
        ECPoint beta = authenticationServerResponse.getBeta();
        ECSchnorrZKP knowledgeProofForX3 = authenticationServerResponse.getKnowledgeProofForX3();
        ECSchnorrZKP knowledgeProofForX4 = authenticationServerResponse.getKnowledgeProofForX4();
        ECSchnorrZKP knowledgeProofForBeta = authenticationServerResponse.getKnowledgeProofForBeta();

        ECPoint betaG = Owl_Util.calculateGA(gx1, gx2, gx3);

        Owl_Util.validateParticipantIdsDiffer(clientId, authenticationServerResponse.getServerId());
        Owl_Util.validateZeroknowledgeProof(g, gx3, knowledgeProofForX3, q, n, ecCurve, h, authenticationServerResponse.getServerId(), digest);
        Owl_Util.validateZeroknowledgeProof(g, gx4, knowledgeProofForX4, q, n, ecCurve, h, authenticationServerResponse.getServerId(), digest);
        Owl_Util.validateZeroknowledgeProof(betaG, beta, knowledgeProofForBeta, q, n, ecCurve, h, authenticationServerResponse.getServerId(), digest);

        ECPoint alphaG = Owl_Util.calculateGA(gx1, gx3, gx4);
        BigInteger x2pi = Owl_Util.calculateX2s(n, x2, pi); 
        ECPoint alpha = Owl_Util.calculateA(alphaG, x2pi);

        ECSchnorrZKP knowledgeProofForAlpha  = Owl_Util.calculateZeroknowledgeProof(alphaG, n, x2pi, alpha, digest, clientId, random);

        this.rawKey = Owl_Util.calculateKeyingMaterial(gx4, x2, x2pi, beta);

        BigInteger hTranscript = Owl_Util.calculateTranscript(rawKey, clientId, gx1, gx2, knowledgeProofForX1, knowledgeProofForX2, serverId, gx3, gx4, 
            knowledgeProofForX3, knowledgeProofForX4, beta, knowledgeProofForBeta, alpha, knowledgeProofForAlpha, digest);

        BigInteger r = Owl_Util.calculateR(x1, t, hTranscript, n);

        this.state = STATE_LOGIN_FINISHED;

        return new Owl_AuthenticationFinish(clientId, alpha, knowledgeProofForAlpha, r);
    }


    /**
     * Calculates and returns the key material.
     * A session key must be derived from this key material using a secure key derivation function (KDF).
     * The KDF used to derive the key is handled externally (i.e. not by {@link Owl_Client}).
     * <p>
     * The keying material will be identical for client and server if and only if
     * the login password is the same as password stored by the server.  i.e. If the client and  
     * server do not share the same password, then each  will derive a different key.
     * Therefore, if you immediately start using a key derived from
     * the keying material, then you must handle detection of incorrect keys.
     * If you want to handle this detection explicitly, you can optionally perform
     * rounds 3 and 4.  See {@link Owl_Client} for details on how to execute
     * rounds 3 and 4.
     * <p>
     * If the passwords used as registration and at login are different then this will be caught
     * when validating r during {@link Owl_Server#authenticationServerEnd(Owl_AuthenticationFinish)}.
     * The keying material will be in the range <tt>[0, n-1]</tt>.
     * <p>
     * {@link #authenticationFinish(Owl_AuthenticationServerResponse)} must be called prior to this method.
     * <p>
     * As a side effect, the internal {@link #password} array is cleared, since it is no longer needed.
     * <p>
     * After execution, the {@link #getState() state} will be  {@link #STATE_KEY_CALCULATED}.
     *
     * @throws IllegalStateException if called prior to {@link #authenticationFinish(Owl_AuthenticationServerResponse)},
     *                               or if called multiple times.
     */
    public BigInteger calculateKeyingMaterial()
    {
        if (this.state >= STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Key already calculated for " + clientId);
        }
        if (this.state < STATE_LOGIN_FINISHED)
        {
            throw new IllegalStateException("Login authentication must be finished prior to creating key for " + clientId);
        }

        /*
         * Clear the password array from memory, since we don't need it anymore.
         *
         * Also set the field to null as a flag to indicate that the key has already been calculated.
         */
        Arrays.fill(password, (char)0);
        this.password = null;
        
        BigInteger keyingMaterial = Owl_Util.deriveKCKey(rawKey);
        /*
         * Clear the ephemeral private key fields as well.
         * Note that we're relying on the garbage collector to do its job to clean these up.
         * The old objects will hang around in memory until the garbage collector destroys them.
         *
         * If the ephemeral private keys x1 and x2 are leaked,
         * the attacker might be able to brute-force the password.
         */
        this.x1 = null;
        this.x2 = null;
        this.t = null;
        this.pi = null;
        this.rawKey = null;

        /*
         * Do not clear gx* yet, since those are needed by round 3.
         */
        this.state = STATE_KEY_CALCULATED;

        return keyingMaterial;
    }

    /**
     * Creates and returns the payload to send to the client as part of Key Confirmation.
     * <p>
     * See {@link Owl_Client} for more details on Key Confirmation.
     * <p>
     * After execution, the {@link #getState() state} will be {@link #STATE_KC_INITIALISED}.
     *
     * @param keyingMaterial            The keying material as returned from {@link #calculateKeyingMaterial()}.
     * @throws IllegalStateException    if called prior to {@link #calculateKeyingMaterial()}, or multiple times
     */
    public Owl_KeyConfirmation initiateKeyConfirmation(BigInteger keyingMaterial)
    {
        if (this.state >= STATE_KC_INITIALISED)
        {
            throw new IllegalStateException("Key Confirmation already initiated for " + this.clientId);
        }
        if (this.state < STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Keying material must be calculated prior to initialising key confirmation for " + this.clientId);
        }

        BigInteger macTag = Owl_Util.calculateMacTag(
            this.clientId,
            this.serverId,
            this.gx1,
            this.gx2,
            this.gx3,
            this.gx4,
            keyingMaterial,
            this.digest);

        this.state = STATE_KC_INITIALISED;

        return new Owl_KeyConfirmation(clientId, macTag);
    }

    /**
     * Creates and returns the payload to send to the client as part of Key Confirmation.
     * <p>
     * See {@link Owl_Client} for more details on Key Confirmation.
     * <p>
     * After execution, the {@link #getState() state} will be {@link #STATE_KC_VALIDATED}.
     *
     * @param keyConfirmationPayload    The key confirmation payload received from the other client.
     * @param keyingMaterial            The keying material as returned from {@link #calculateKeyingMaterial()}.
     * @throws CryptoException          if validation fails.
     * @throws IllegalStateException    if called prior to {@link #calculateKeyingMaterial()}, or multiple times
     */
    public void validateKeyConfirmation(Owl_KeyConfirmation keyConfirmationPayload, BigInteger keyingMaterial)
        throws CryptoException
    {
        if (this.state >= STATE_KC_VALIDATED)
        {
            throw new IllegalStateException("Validation already attempted for this payload for" + clientId);
        }
        if (this.state < STATE_KEY_CALCULATED)
        {
            throw new IllegalStateException("Keying material must be calculated prior to validating this payload for " + this.clientId);
        }
        Owl_Util.validateParticipantIdsDiffer(clientId, keyConfirmationPayload.getId());
        Owl_Util.validateParticipantIdsEqual(this.serverId, keyConfirmationPayload.getId());

        Owl_Util.validateMacTag(
            this.clientId,
            this.serverId,
            this.gx1,
            this.gx2,
            this.gx3,
            this.gx4,
            keyingMaterial,
            this.digest,
            keyConfirmationPayload.getMacTag());


        /*
         * Clear the rest of the fields.
         */
        this.gx1 = null;
        this.gx2 = null;
        this.gx3 = null;
        this.gx4 = null;

        this.state = STATE_KC_VALIDATED;
    }

    private BigInteger calculateT()
    {
        try 
        {
            return Owl_Util.calculateT(n, clientId + new String(password), digest);
        } 
        catch (CryptoException e)
        {
            throw Exceptions.illegalStateException(e.getMessage(), e);
        }
    }

    private BigInteger calculatePi()
    {
        try 
        {
            return Owl_Util.calculatePi(n, t, digest);
        }
        catch (CryptoException e)
        {
            throw Exceptions.illegalStateException(e.getMessage(), e);
        }
    }
}